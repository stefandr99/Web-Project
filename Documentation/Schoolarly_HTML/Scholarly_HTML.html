<!DOCTYPE html>
<html>
  <head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Scholarly HTML</title>
    <link rel="stylesheet" href="./scholarly.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <script src="./Scholarly HTML_files/scholarly.min.js.download"></script>
  </head>
  <body prefix="schema: http://schema.org" cz-shortcut-listen="true">
    <div class="banner">
      <img src="./diagrams/scholarly-html.svg" width="227" height="50" alt="Scholarly HTML logo">
      <div class="status">Open Dataset Visualizer</div>
    </div>
    <header>
      <h1>ODA Scholarly HTML</h1>
    </header>
    <div role="contentinfo">
      <ol role="directory">
        <li><a href="#abstract"><span>1. </span>Abstract</a></li>
        <li><a href="#introduction"><span>2. </span>Introduction</a></li>
        <li><a href="#architecture"><span>3. </span>Arhitecture</a></li>
        <li><a href="#software-design"><span>4. </span>Software Design</a>
          <ol>
            <li><a href="#software-design-uml-activity"><span>4.1. </span>UML Activity Diagram</a></li>
            <li><a href="#software-design-use-case"><span>4.2. </span>UML Use Case Diagram</a></li>
            <li><a href="#software-design-use-case"><span>4.3. </span>UML Sequence Diagram</a></li>
          </ol>
        </li>
        <li><a href="#spqrql"><span>5. </span>SPARQL and Datasets</a>
          <ol>
            <li><a href="#sparql-subsection"><span>5.1. </span>SPARQL</a></li>
            <li><a href="#datasets"><span>5.2. </span>Datasets</a></li>
            <li><a href="#sparql-endpoint"><span>5.3. </span>SPARQL endpoint</a></li>
          </ol>
        </li>
        <li><a href="#auth"><span>6. </span>Authentication and authorization</a>
          <ol>
            <li><a href="#auth-authentication"><span>6.1. </span>Authentication endpoints</a></li>
            <li><a href="#auth-authentication"><span>6.2. </span>Authorization endpoints</a></li>
          </ol>  
        </li>
        <li><a href="#deployment"><span>7. Application Deploy</span></a>
      <dl>
        <dt>Authors</dt>
        <dd>
          Nazar Fatichov,
          Serghei Cunev 
          &amp;
          Ștefan Drăgoi
        </dd>
      </dl>
    </div>
    <section typeof="sa:Abstract" id="abstract" role="doc-abstract">
      <h2><span>1. </span>Abstract</h2>
      <p>
        ODA (Open Dataset Visualizer) is a semantic web applicaton which has the purpose to represent data 
        from open datasets in different forms. The main target of the application is to provide userful visualizations 
        to end users in order to understand better data / information / knowledge. The system is designed to allow users 
        to write a raw SPARQL queries, to specify which column of their representation they want to be included in the resulted 
        chart and in what type of chart they want to be data represented.
      </p>
    </section>
    <section id="introduction" role="doc-introduction">
      <h2><span>2. </span>Introduction and project progress</h2>
      <p>
        Open Dataset Visualizer is a web application which will provide useful visualizations for better understanding of 
        data retrieved via a SPARQL endpoint. In the following two subsection we will describe the initial goals of the
        application and the what we've managed to implement.


        <section>

          <h3><span>2.1 </span>Initial goals</h3>

          <ul>
            <li>
              write raw SPARQL queries in the application's query editor, choose which columns of retrieved data will be represented 
              and what kind diagrams will represent the result;
            </li>
            <li>
              save certain charts to be used later with other purposes;
            </li>
            <li>
              update saved diagrams by adding, deleting, modifing columns / data source;
            </li>
            <li>
              delete a saved representation associated with their account;
            </li>
            <li>
              share a chart with another user; 
            </li>
          </ul>
        </p>
        <p>
          The application is built in 3 modules (which will be described in the following document sections):
          <ul>
            <li>
              Authentication and authorization web API;
            </li>
            <li>
              SPQRQL data retrieving web API;
            </li>
            <li>
              User interface and user experience: writing queries, visualize charts (represented data), save and 
              share charts
            </li>
          </ul>
        </p>

        </section>

        <section>

          <h3><span>2.2 </span>What we've achieved</h3>

          <p>We have successfully implemented all the initial goals outlined, with the exception of updating saved diagrams. The application has been developed in three modules: the Authentication and authorization web API, the SPARQL data retrieving web API, and the User interface and user experience, which includes writing queries, visualizing charts, saving and sharing charts. The users are able to write raw SPARQL queries in the application's query editor, select columns of retrieved data to be represented, and choose the type of diagrams to display the results. They are able to save charts for future use and share them with other users, but currently cannot update the saved diagrams by adding, deleting, or modifying columns or data sources.</p>

          <p>Furthermore, it is also worth mentioning that we have utilized d3-sparql instead of communica for querying SPARQL data. d3-sparql is a library that facilitates the retrieval and visualization of RDF data using SPARQL queries, and it provides a simple and intuitive interface for developers. By using d3-sparql, we have been able to leverage its capabilities to enhance the functionality of our application and provide a better user experience. This choice of library has allowed us to effectively manage the data retrieval and visualization process, while also providing a high level of customization and control for users.</p>
        </section>

       
    </section>

    <section id="architecture">
      <h2><span>3. </span>Arhitecture</h2>
      <p>
        Our application architecture will be described via the following diagrams:
      </p>
      <div style="display: flex; justify-content:center; align-items: center; flex-direction: column; ">
        <img style="max-width: 100%" src="./diagrams/backend_architecture.png" />
        <figcaption style="font-style: italic; margin-top: 12px;">Fig.1 - ODa Backend architecture</figcaption>
      </div>
      <p>For the backend we've decided to take a modular - microservice approach. This can help us develop the modules independently and integrate those together when they are done. Such approach
        also helps us with the testing and allows each person responsible for the microservice to develop in the desired language without imposing it on the other developers. All the microservices
      will be glued together with the help of an API Gateway. Diving deeper into each of the microservices :</p>
      <ul>
        <li>
          <b>Authentication and authorization</b> - this microservice will be responsible for the authentication and authorization of the users. 
           It will be implemented in Java using Spring Boot. The authorization will be done using the roles of the users.
        </li>
        <li>
          <b>SPARQL Query Microservice</b> - this microservice will be responsible for the retrieval of the data from the SPARQL endpoint. 
          It will be implemented in NodeJS. The data will be retrieved using the SPARQL queries written by the users.
        </li>
        <li>
          <b>Sharing Visualization Microservice</b> - this microservice will be responsible for the sharing of the visualizations between users.
        </li>
      </ul>
      <div style="display: flex; justify-content:center; align-items: center; flex-direction: column; ">
        <img style="max-width: 100%" src="./diagrams/frontend_architecture.png" />
        <figcaption style="font-style: italic; margin-top: 12px;">Fig.2 - ODa Frontend architecture</figcaption>
      </div>
      <p>For the frontend we've decided to use React as the frontend backbone because of the flexibility this library offers. With the help of React we can create SPA's that 
        can easily act both as an application and a browser extension. Diving deeper into the React app, we can see the following modules
      </p>
      <ul>
        <li>
          <b>Client state management - Zustand</b> : Zustand is a state management library that is built on top of React.
           It is very lightweight and easy to use. It is also very flexible and allows us to create our own state management system.
        </li>
        <li>
          <b> d3-sparql </b> is a JavaScript library that allows you to visualize SPARQL query results with D3.js, a popular data visualization library. The library provides an interface for fetching query results from a SPARQL endpoint and transforming them into the format required by D3, making it easy to create interactive, dynamic visualizations based on linked data.
        </li>
        <li>
          <b>Routing - react-router</b> : react-router is a routing library for React. It allows us to create routes and navigate between them.
        </li>
        <li>
          <b>Charts - Recharts</b> : Recharts is a charting library for React. It is very flexible and allows us to create different types of charts.
        </li>
      </ul>
    </section>

    <section id="software-design">
      <h2><span>4. </span>Software Design</h2>
      <p>
        We've designed a set of diagrams that will explain all the flow that the users can have within the application as well as how the modules of our application interact 
        with each other and what's the sequence of the actions that the user can perform. 
      </p>
      <section id="software-design-uml-activity">
        <h3><span>4.1 </span>UML Activity Diagram</h3>
        <div style="display: flex; justify-content:center; align-items: center; flex-direction: column; ">
          <img style="max-width: 90%" src="./diagrams/uml_activity_diagram.png" />
          <figcaption style="font-style: italic; margin-top: 12px;">Fig.3 - ODa UML Activity Diagram</figcaption>
        </div>
        <p>
          The activity diagram describes the flow of the user actions within the application in order of their execution. When the user will first enter the application he 
          can directly input the SPARQL query in the query editor and execute it. After the query has been executed and the user received the data he can choose which columns he wants to
          visualize and what type of visualization he wants to use. After the user has chosen the columns and the type of visualization he will see the visualization.
          The user then can save the visualization if he wants to for later use, but in order to do that he will have to create an account. If the user already has an account he can login.
          After the user has logged in he can save the visualization and use it later. The user can also share the visualization with other users. The user can view other user's visualizations
          and use them for his own purposes if he has the permission to do so and the link to the visualization
        </p>
      </section>
      <section id="software-design-use-case">
        <h3><span>4.2 </span>UML Use Case Diagram</h3>
        <div style="display: flex; justify-content:center; align-items: center; flex-direction: column;">
          <img style="max-width: 90%" src="./diagrams/uml_use_case_diagram.png" />
          <figcaption style="font-style: italic;margin-top: 12px;">Fig.4 - ODa UML Use Case Diagram</figcaption>
        </div>
        <p>
          The use case diagram describes the users we will have in our application and the actions that they can perform. 
          We will have 2 types of users: the users that are not logged in and the users that are logged in which are called unauthorised and authorised user.
          Unauthorised users can perform the following actions
          <ul>
            <li>
              Execute SPARQL queries
            </li>
            <li>
              Visualize the data with the desired visualization and with the desired columns
            </li>
            <li>
              Create an account
            </li>
            <li>
              Login
            </li>
            <li>
              View other user's visualizations if those are publicly available
            </li>
          </ul>
          Authorised users can perform all the actions unauthorised can and also the following actions
          <ul>
            <li>
              Save the visualizations
            </li>
            <li>
              View saved visualizations
            </li>
            <li>
              Share the visualizations with other users
            </li>
            <li>
              View other user's visualizations if the user has the permission to view them
            </li>
        </p>
      </section>
      <section id="software-design-use-case">
        <h3><span>4.3 </span>UML Sequence Diagram</h3>
        <div style="display: flex; justify-content:center; align-items: center; flex-direction: column;">
          <img style="max-width: 90%" src="./diagrams/uml_sequence_diagram.png" />
          <figcaption style="font-style: italic; margin-top: 12px;">Fig.5 - ODa UML Sequence Diagram</figcaption>
        </div>
        <p>
          The sequence diagram describes how modules interact with each other based on the user actions. ODa module represents the front-end application and is the only thing that the user interacts with.
          The ODa module will send the SPARQL query to the SPARQL Query Microservice. The SPARQL Query Microservice will send the query to the SPARQL endpoint and will receive the data.
          The SPARQL Query Microservice will send the data to the ODa module and the ODa module will display the data to the user. The user can then choose which columns he wants to visualize and what type of visualization he wants to use.
          The ODa module within it will create the visualization and will show it to the user.
          If the user wants to save the visualization he will have to create an account or login if he already has an account.
          The ODa module will send the request to the Auth Microservice with the credentials the user entered.
          The Auth Microservice will check if the user credentials are valid and will send back the response if the user is allowed to save the visualization.
          If the user is allowed to save the visualization the ODa module will send the request to the Sharing Microservice with the data of the visualization.
          The Sharing Microservice will save the visualization in the Database and will send back the response to the ODa module.
          If the user wants to share the visualization with other users he will select which visualization he wants to share.
          The ODa module will send the request to the Sharing Microservice with the data of the visualization.
          The Sharing Microservice will change the permissions to the visualization and will send back the response to the ODa module.
          If the user wants to view other user's visualizations he will enter the link of the visualization.
          The ODa module will send the request to the Sharing Microservice with the link of the visualization.
          The Sharing Microservice will check if the user has the permission to view the visualization and will send back the response to the ODa module.

        </p>
      </section>
    </section>

    <section id="front-end">
      <h2><span>5. </span>Front-End</h2>
      <section>
        <h3><span>5.1 </span>Vite</h3>
        <p>
          Vite is a build tool that aims to provide a faster and leaner development experience for modern web projects. It consists of two major parts:
          <ul>
            <li>
              A dev server that provides rich feature enhancements over native ES modules, for example extremely fast Hot Module Replacement (HMR).
            </li>
            <li>
              A build command that bundles your code with Rollup, pre-configured to output highly optimized static assets for production.
            </li>
          </ul>
          Vite is opinionated and comes with a number of built-in features out of the box, such as:
          <ul>
            <li>
              ES module based dev server that supports native ESM imports during development.
            </li>
            <li>
              Rich feature enhancements over native ES modules, for example extremely fast Hot Module Replacement (HMR).
            </li>
            <li>
              Rollup based build command that bundles your code with Rollup, pre-configured to output highly optimized static assets for production.
            </li>
            <li>
              TypeScript support.
            </li>
            <li>
              JSX/TSX support.
            </li>
        </p>
      </section>
      <section>
        <h3><span>5.2 </span>React with TypeScript</h3>
        <p>
          React is a JavaScript library for building user interfaces. It is maintained by Facebook and a community of individual developers and companies.
          React can be used as a base in the development of single-page or mobile applications. However, React is only concerned with rendering data to the DOM, and so creating React applications usually requires the use of additional libraries for state management and routing.
          TypeScript is an open-source language which builds on JavaScript, one of the world’s most used tools, by adding static type definitions.
          TypeScript saves you time catching errors and providing fixes before you run code.
          TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.
          Any browser. Any host. Any OS. Open source.
        </p>
      </section>
      <section>
        <h3><span>5.3</span> Mantine UI</h3>
        <p>
          Mantine is a React UI library that provides a set of components and hooks to build your own design system or design a new website.
          It has multiple utilities that we've used across the app
          <ul>
            <li>
              <code>@mantine/core</code> - Mantine core components, such as buttons, inputs, selects, etc.
              <div style="display:flex;flex-direction:column; align-items:center;">
              <img style="max-width: 100%; margin-top: 12px;" src="./diagrams/ui_core_components.png" />
                <figcaption style="font-style: italic; margin-top: 12px; margin-bottom:12px">Fig.6 - UI Built with Mantine</figcaption>
              </div>


            </li>
            <li>
              <code>@mantine/form</code> - Mantine form components, such as form, form control, form error, etc.
              <div style="display:flex;flex-direction:column; align-items:center;">
                <img style="max-width: 100%; margin-top: 12px;" src="./diagrams/form_example.png" />
                  <figcaption style="font-style: italic; margin-top: 12px; margin-bottom:12px">Fig.7 - Form Built with Mantine</figcaption>
                </div>
            </li>
            <li>
              <code>@mantine/hooks</code> - Mantine hooks, such as use-id, use-merge-refs, use-previous-value, etc.
            </li>
            <li>
              <code>@mantine/styles</code> - Mantine styles, such as create-mantine-theme, create-use-styles, etc.
            </li>
            <li>
              <code>@mantine/theme</code> - Mantine theme, such as MantineProvider, use-mantine-theme, etc.
            </li>
            <li><code>@mantine/notifications</code> - Mantine notifications, mainly the showNotification function.</li>
          </ul>
        </p>
      </section>

      <section>
        <h3><span>5.4</span> Zustand</h3>
        <p>
          We have two stores across the app, one for the user and one for the visualizations.
          <ul>
            <li>
              <code>userStore</code> - The user store is used to store the user's data, such as the username, the email, the avatar, bearer token etc.
              Also, this store persists, so the user's data is stored in the local storage.
              <div style="display:flex;flex-direction:column; align-items:center;">
                <img style="max-width: 100%; margin-top: 12px;" src="./diagrams/userStore.png" />
                  <figcaption style="font-style: italic; margin-top: 12px; margin-bottom:12px">Fig.8 - User Store</figcaption>
                </div>
            </li>
            <li>
              <code>applicationStore</code> - The application store is used to store the visualizations data, such as the title, the description, the data, the type of chart, as well as the steps of the visualization creation process.
              <div style="display:flex;flex-direction:column; align-items:center;">
                <img style="max-width: 100%; margin-top: 12px;" src="./diagrams/applicationStore.png" />
                  <figcaption style="font-style: italic; margin-top: 12px; margin-bottom:12px">Fig.9 - Application store</figcaption>
                </div>
            </li>
          </ul>
          
        </p>
      </section>
      <section>
        <h3><span>5.5</span> CodeMirror</h3>
        <p>
          CodeMirror is a versatile text editor implemented in JavaScript for the browser. It is specialized for editing code, and comes with a number of language modes and addons that implement more advanced editing functionality.
          We have used CodeMirror to implement the SPQRQL editor.
         </p>
         <p>
          <code>@uiw/react-codemirror</code> is a React library that provides a React component for integrating CodeMirror.
          The library wraps the CodeMirror editor in a React component, making it easier to use and integrate into React projects, like ours.
          </p>
          <div style="display:flex;flex-direction:column; align-items:center;">
            <img style="max-width: 100%; margin-top: 12px;" src="./diagrams/codemirror.png" />
              <figcaption style="font-style: italic; margin-top: 12px; margin-bottom:12px">Fig.9 - CodeMirror in Theia</figcaption>
            </div>
      </section>

      <section>
        <h3><span>5.6</span> Recharts</h3>
        <p>
          Recharts is a Redefined chart library built with React and D3.
          We have used Recharts to implement the charts.
          </p>
          <p>Example of implemented charts</p>
          <ul>
            <li>
              <code>BarChart</code> - Bar chart
              <div style="display:flex;flex-direction:column; align-items:center;">
                <img style="max-width: 100%; margin-top: 12px;" src="./diagrams/bar_chart.png" />
                  <figcaption style="font-style: italic; margin-top: 12px; margin-bottom:12px">Fig.10 - Bar Chart</figcaption>
                </div>
            </li>
            <li>
              <code>LineChart</code> - Line chart
              <div style="display:flex;flex-direction:column; align-items:center;">
                <img style="max-width: 100%; margin-top: 12px;" src="./diagrams/line_chart.png" />
                  <figcaption style="font-style: italic; margin-top: 12px; margin-bottom:12px">Fig.11 - Line Chart</figcaption>
                </div>
            </li>
            <li>
              <code>PieChart</code> - Pie chart
              <div style="display:flex;flex-direction:column; align-items:center;">
                <img style="max-width: 100%; margin-top: 12px;" src="./diagrams/pie_chart.png" />
                  <figcaption style="font-style: italic; margin-top: 12px; margin-bottom:12px">Fig.12 - Pie Chart</figcaption>
                </div>
            </li>
            <li>
              <code>ScatterChart</code> - Scatter chart
              <div style="display:flex;flex-direction:column; align-items:center;">
                <img style="max-width: 100%; margin-top: 12px;" src="./diagrams/scatter_chart.png" />
                  <figcaption style="font-style: italic; margin-top: 12px; margin-bottom:12px">Fig.13 - Scatter Chart</figcaption>
                </div>
            </li>
            <li>
              <code>RadarChart</code> - Radar Chart
              <div style="display:flex;flex-direction:column; align-items:center;">
                <img style="max-width: 100%; margin-top: 12px;" src="./diagrams/radar_chart.png" />
                  <figcaption style="font-style: italic; margin-top: 12px; margin-bottom:12px">Fig.14 - Radar Chart</figcaption>
                </div>
            </li>
            <li>
              <code>Radial Chart</code> - Radial Chart
              <div style="display:flex;flex-direction:column; align-items:center;">
                <img style="max-width: 100%; margin-top: 12px;" src="./diagrams/radial_chart.png" />
                  <figcaption style="font-style: italic; margin-top: 12px; margin-bottom:12px">Fig.15 - Radial Chart</figcaption>
                </div>
            </li>

          </ul>
      </section>

      <section>
        <h3><span>5.7</span>JSON-LD Detection</h3>

        <p>
          JSON-LD is a JSON-based format to serialize <a href="https://www.w3.org/TR/json-ld/">Linked Data</a>. 
          It is designed to be easy to read for humans and to be easy to generate and parse by machines. 
          JSON-LD is primarily intended to be a way to use Linked Data in Web-based programming environments, 
          to build interoperable Web services, and to store Linked Data in JSON-based storage engines.
        </p>
        <p>
          We have used <code>schema-dts</code> and <code>react-schemaorg</code> to place JSON-LD on our pages so that search engines can understand the content of our pages.
        </p>
        <p>
          The types of JSON-LD we have used are:
          <ul>
        <li>
          <code>WebApplication</code>
        </li>
        <li>
          <code>WebPage</code>
        </li>
        <li>
          <code>Dataset</code>
        </li>
        <li>
          <code>Collection</code>
        </li>
        <li>
          <code>CollectionPage</code>
        </li>
        <li>
          <code>CreativeWork</code>
        </li>
        <li>
          <code>Table</code>
        </li>
        <li>
          <code>Recommendation</code>
        </li>
          </ul>
        <div style="display:flex;flex-direction:column; align-items:center;">
          <img style="max-width: 100%; margin-top: 12px;" src="./diagrams/json_ld.png" />
          <figcaption style="font-style: italic; margin-top: 12px; margin-bottom:12px">Fig.17 - OpenLink Structured Data Sniffer Page Analysis</figcaption>
        </div>
        </p>
      </section>


    </section>

    <section id="spqrql">
      <h2><span>5. </span>SPQRQL and Datasets</h2>
      <p>
        The application will be used by users to represent different kind of data in several types of charts. 
        The information is retireved via a SPARQL endpoint implemented in <a href="https://nodejs.org/en/">Node.js</a> from different open datasets.
      </p>
      <section id="sparql-subsection">
        <h3><span>5.1 </span>SPAQRL</h3>
        <p>
          SPARQL is a <a href="https://www.w3.org/TR/sparql11-query/">query language</a> and a 
          <a href="https://www.w3.org/TR/rdf-sparql-protocol/">protocol</a> 
          for accessing RDF designed by <a href="https://www.w3.org/2009/sparql/wiki/Main_Page">W3C</a>. 
        </p>
        <p>
          As a query language, SPARQL is “data-oriented” in that it only queries the information held in the models; 
          there is no inference in the query language itself.  Of course, the Jena model may be ‘smart’ in that it 
          provides the impression that certain triples exist by creating them on-demand, including OWL reasoning. 
          SPARQL does not do anything other than take the description of what the application wants, in the form of a query, 
          and returns that information, in the form of a set of bindings or an RDF graph. (Apache Jena)
        </p>
      </section>
      <section id="datasets">
        <h3><span>5.2 </span>Datasets</h3>
        <p>
          In ODA, when an user wants to retireve data by writing an SPARQL query in the page query editor, they will be able 
          to specify which open dataset they target. Being a flexible application, user has the posibility to insert the link of
          the most used open datasets:
          <ul>
            <li>
              <a href="https://www.dbpedia.org/">Dbpedia</a>
            </li>
            <li>
              <a href="https://www.wikidata.org/wiki/Wikidata:Main_Page">Wikidata</a>
            </li>
          </ul>
        </p>
      </section>
      <section id="sparql-endpoint">
        <h3><span>5.3 </span>SPARQL endpoint</h3>
        <p>
          In order to retireve data from chosen open dataset, the user has to write a SPQRQL query in the 
          query editor. When submitting the written query, an API call will be made by the front-end application.
          That API will execute the query on the specified open dataset and return the results in order to be 
          represented in different ways in the page application.
        </p>
        <p>
          The SPARQL endpoint is implemented in <a href="https://nodejs.org/en/">Node.js</a>, an open source server environment 
          which uses JavaScript in the server. The endpoint will use <a href="https://expressjs.com/">ExpressJS</a>, a minimal 
          and flexible <a href="https://nodejs.org/en/">Node.js</a> web application framework.
        </p>
        <p>
          We've decided to use the d3-sparql library in order to execute the SPARQL queries. The d3-sparql library is a
          <a href="https://www.npmjs.com/package/d3-sparql">Node.js</a> library that allows to execute SPARQL queries and
          to retrieve the results in JSON format. The library is based on the <a href="https://www.npmjs.com/package/sparql-client">sparql-client</a> library.
        </p>
        <p>
          We will have the following endpoints:
          <ul>
            <li>
              <code>POST /sparql/</code> - It takes JSON payload in the request body that contains two properties: endpoint and query.
              It uses the d3.sparql function to make a SPARQL query to the specified endpoint with the given query.
               The results are then processed using OpenAI's Generative Pre-trained Transformer 3 (GPT-3) <code>openai.createCompletion</code> function,
                to suggest a graph type and generate natural language descriptions of the data. Finally, the results and the graph suggestion are sent back as a JSON response.
            </li>
            <li>
              <code>POST /sparql/simple</code> - It is similar / route, but it does not make use of the OpenAI function.
               It only retrieves the results of the SPARQL query and returns them as a JSON response.
            </li>
        </p>
        <p>
          <span style="font-weight: 700;">Example Query</span>
          <pre><code>
            const bindingsStream = await queryEngine.queryBindings(
              `PREFIX dbo: <http://dbpedia.org/ontology/>
              PREFIX foaf: <http://xmlns.com/foaf/0.1/>
              PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> 
              SELECT ?country ?city ?city_name ?country_name
              WHERE {
                  ?city rdf:type dbo:City ;
                        foaf:name ?city_name ;
                        dbo:country ?country ;
                        dbo:populationTotal ?population ;
                        ?country rdf:type dbo:Country ;
                            foaf:name ?country_name .
              
                  ?country foaf:name \"Romania\"@en .
              
                  FILTER(langMatches(lang(?city_name), \"en\"))
              }
              ORDER BY ?city_name
              LIMIT 100`,
              {
                sources: ['https://dbpedia.org/sparql'],
              },
            );
          </code></pre>
        </p>
      </section>
    </section>
    <section id="auth">
      <h2><span>6. </span>Authentication and authorization</h2>
      <p>
        ODA application allows users to qury an open dataset via a SPARQL endpoint implemented in Node.js as described above. In order to perform 
        all specified actions, firstly they have to register in the application with an username and a password. Based on their credentials, 
        the users will be allowed to save and update an SPARQL query or to share a query with another application user.
        As it can be seen in the project architecture presented above, there will be implementend three microservice for every section of the 
        application: authentication, open datasets queries and authorization in order to perform different actions to an executed query.
      </p>
      <section id="auth-authentication">
        <h3><span>6.1 </span>Authentication endpoints</h3>
          In order to save, update and delete or to share a SPARQL query, the users should have an account. For this part of the application 
          we will have an authentication microservice implemented in Java Spring Framework.
          For authentication there will be the following Java endpoints:
          <ul>
            <li>
              POST: <b>auth/user</b> - create an user account
            </li>
            <li>
              GET: <b>auth/user/{id}</b> - get user account by id
            </li>
            <li>
              PUT: <b>auth/user/{id}</b> - update an user credentials 
            </li>
            <li>
              DELETE: <b>auth/user/{id}</b> - delete an user account
            </li>
          </ul>
      </section>
      <section id="auth-authentication">
        <h3><span>6.2 </span>Authorization endpoints</h3>
        Having an account, users are allowed to share their SPARQL queries and their visualization with other users on the platform.
        To do so, they must have the permission to share a specific query. This part of the application will be represented by another 
        microservice implemented in Java Spring Framework.
        For authorization there will be the following Java endpoints:
        <ul>
          <li>
            POST: <b>auth/access</b> - create a permission for a specific query
          </li>
          <li>
            GET: <b>auth/access/{userId}</b> - get all user's query list by user id
          </li>
          <li>
            PUT: <b>auth/user/{userId}</b> - update permissions for a query 
          </li>
          <li>
            DELETE: <b>auth/user/{userId}/{queryId}</b> - delete an user's query 
          </li>
        </ul>
      </section>
    </section>
    <section id="deployment">
      <h2><span>7. </span>Application Deploy</h2>
      <p>
        The React app will be hosted on Netlify, the Express app will be hosted on Fly.io.
      </p>
      <ul>
        <li>
          The React app is available at <a href="https://theia-oda.netlify.app/">https://theia-oda.netlify.app/</a>
        </li>
        <li>
          The API endpoints are available at <a href="https://theia-oda.fly.dev">https://theia-oda.fly.dev</a>
        </li>
      </ul>
      <p>
        Netlify is a cloud-based platform that provides hosting, continuous deployment, and management services for modern web applications. It is designed to simplify the development and deployment of web applications, allowing developers to focus on writing code while the platform takes care of the underlying infrastructure. Netlify supports a wide range of web technologies and provides a variety of tools and features for managing and optimizing web applications, such as automatic optimization for faster loading times, automatic SSL certificates, and custom domains.
      </p>
      <p>
        Fly.io is a cloud platform that provides hosting and management services for server-side applications, including those built with Express.js. It offers automatic scaling, global content delivery, and custom domains, as well as other features for managing and optimizing server-side applications. Fly.io provides a secure and reliable platform for deploying and running server-side applications, freeing developers from the complexities of managing infrastructure and allowing them to focus on writing code. The platform provides a simple and intuitive interface for managing server-side applications, making it an attractive option for us.
      </p>

    </section>
    </body>
    </html>