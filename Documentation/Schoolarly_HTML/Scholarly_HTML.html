<!DOCTYPE html>
<html>
  <head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Scholarly HTML</title>
    <link rel="stylesheet" href="./scholarly.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <script src="./Scholarly HTML_files/scholarly.min.js.download"></script>
  </head>
  <body prefix="schema: http://schema.org" cz-shortcut-listen="true">
    <div class="banner">
      <img src="./icon/scholarly-html.svg" width="227" height="50" alt="Scholarly HTML logo">
      <div class="status">Open Dataset Visualizer</div>
    </div>
    <header>
      <h1>ODA Scholarly HTML</h1>
    </header>
    <div role="contentinfo">
      <ol role="directory">
        <li><a href="#abstract"><span>1. </span>Abstract</a></li>
        <li><a href="#introduction"><span>2. </span>Introduction</a></li>
        <ol>
          <li><a href="#introduction-initial-goals"><span>2.1. </span>Initial goals</a></li>
          <li><a href="#introduction-achievements"><span>2.2. </span>What we've achieved</a></li>
        </ol>
        <li><a href="#architecture"><span>3. </span>Arhitecture</a></li>
        <li><a href="#software-design"><span>4. </span>Software Design</a>
          <ol>
            <li><a href="#software-design-uml-activity"><span>4.1. </span>UML Activity Diagram</a></li>
            <li><a href="#software-design-use-case"><span>4.2. </span>UML Use Case Diagram</a></li>
            <li><a href="#software-design-use-case"><span>4.3. </span>UML Sequence Diagram</a></li>
          </ol>
        </li>
        <li><a href="#front-end"><span>5. </span>Front-End</a>
          <ol>
            <li><a href="#front-end-vite"><span>5.1. </span>Vite</a></li>
            <li><a href="#front-end-react"><span>5.2. </span>React with TypeScript</a></li>
            <li><a href="#front-end-mantine"><span>5.3. </span>Mantine UI</a></li>
            <li><a href="#front-end-zustand"><span>5.4. </span>Zustand</a></li>
            <li><a href="#front-end-codeMirror"><span>5.5. </span>CodeMirror</a></li>
            <li><a href="#front-end-recharts"><span>5.6. </span>Recharts</a></li>
            <li><a href="#front-end-jsonld"><span>5.7. </span>JSON-LD Detection</a></li>
          </ol>
        </li>
        <li><a href="#spqrql"><span>6. </span>SPARQL and Datasets</a>
          <ol>
            <li><a href="#sparql-subsection"><span>6.1. </span>SPARQL</a></li>
            <li><a href="#datasets"><span>6.2. </span>Datasets</a></li>
            <li><a href="#sparql-endpoint"><span>6.3. </span>SPARQL endpoint</a></li>
          </ol>
        </li>
        <li><a href="#user"><span>7. </span>User management and Authentication modules</a>
          <ol>
            <li><a href="#user-authentication"><span>7.1. </span>Authentication module</a></li>
            <li><a href="#user-management"><span>7.2. </span>User module</a></li>
          </ol>  
        </li>
        <li><a href="#deployment"><span>8. Application Deploy</span></a>
      <dl>
        <dt>Authors</dt>
        <dd>
          Nazar Fatichov,
          Serghei Cunev 
          &amp;
          Ștefan Drăgoi
        </dd>
      </dl>
    </div>
    <section typeof="sa:Abstract" id="abstract" role="doc-abstract">
      <h2><span>1. </span>Abstract</h2>
      <p>
        ODA (Open Dataset Visualizer) is a semantic web applicaton which has the purpose to represent data 
        from open datasets in different forms. The main target of the application is to provide userful visualizations 
        to end users in order to understand better data / information / knowledge. The system is designed to allow users 
        to write a raw SPARQL queries specifying the dataset URL or to choose one of the application query from the top 
        right of the page. The users are able to select the type of chart to represent data, which fields to be included in 
        representation, to save a visualization and to share it with a friend.
      </p>
    </section>
    <section id="introduction" role="doc-introduction">
      <h2><span>2. </span>Introduction and project progress</h2>
      <p>
        Open Dataset Visualizer is a web application which will provide useful visualizations for better understanding of 
        data retrieved via a SPARQL endpoint. In the following two subsection we will describe the initial goals of the
        application and the what we've managed to implement.


        <section id="introduction-initial-goals">

          <h3><span>2.1 </span>Initial goals</h3>

          <ul>
            <li>
              write raw SPARQL queries in the application's query editor, choose which columns of retrieved data will be represented 
              and what kind diagrams will represent the result;
            </li>
            <li>
              save certain charts to be used later with other purposes;
            </li>
            <li>
              update saved diagrams by adding, deleting, modifing columns / data source;
            </li>
            <li>
              delete a saved representation associated with their account;
            </li>
            <li>
              share a chart with another user; 
            </li>
          </ul>
        </p>
        <p>
          The application is built in 2 modules (which will be described in the following document sections):
          <ul>
            <li>
              Backend module managing user data and executing the written SPARQL queries. It is an Web API 
              application with two types of endpoints: SPARQL endpoints (one with ChatGPT integration and one without) 
              and user endpoints (create account, login, save visualization, share and see saved data representations) 
            </li>
            <li>
              User interface and user experience: register, login, logout, write queries, visualize charts (represented data), 
              save and share charts
            </li>
          </ul>
        </p>

        </section>

        <section id="introduction-achievements">

          <h3><span>2.2 </span>What we've achieved</h3>

          <p>We have successfully implemented all the initial goals outlined, with the exception of updating saved diagrams. The application has been developed in three modules: the Authentication web API, the SPARQL data retrieving web API, and the User interface and user experience, which includes writing queries, visualizing charts, saving and sharing charts. The users are able to write raw SPARQL queries in the application's query editor, select columns of retrieved data to be represented, and choose the type of diagrams to display the results. They are able to save charts for future use and share them with other users, but currently cannot update the saved diagrams by adding, deleting, or modifying columns or data sources.</p>

          <p>Furthermore, it is also worth mentioning that we have utilized d3-sparql instead of communica for querying SPARQL data. d3-sparql is a library that facilitates the retrieval and visualization of RDF data using SPARQL queries, and it provides a simple and intuitive interface for developers. By using d3-sparql, we have been able to leverage its capabilities to enhance the functionality of our application and provide a better user experience. This choice of library has allowed us to effectively manage the data retrieval and visualization process, while also providing a high level of customization and control for users.</p>
        </section>

       
    </section>

    <section id="architecture">
      <h2><span>3. </span>Arhitecture</h2>
      <p>
        Our application architecture will be described via the following diagrams:
      </p>
      <div style="display: flex; justify-content:center; align-items: center; flex-direction: column; ">
        <img style="max-width: 100%" src="./diagrams/backend_architecture.png" />
        <figcaption style="font-style: italic; margin-top: 12px;">Fig.1 - ODa Backend architecture</figcaption>
      </div>
      <p>
        For the backend we've decided to take a monolith approach, but dividing the routes in two categories: SPARQL endpoints 
        which retrieve data from open datasources based on a query plus asking ChatGPT related to the most suitable chart for the 
        given data and user endpoints which manage user management logic such as create an account, log in the application, save 
        a grapghic representation and share it with friends. Diving deeper into each of this two modules:
      </p>
      <ul>
        <li>
          <b>SPARQL module</b> - this controller will make use of openAI API which will allows us to interact with ChatGPT in order to
          receive the most suitable representation for that kind of data (obtained by executing SPARQL query). This one will generate also 
          a natural language description of the data which will be exposed to the end user in the interface.
        </li>
        <li>
          <b>User management module</b> - this module is responsible with user data management across the application. This controller has 
          several user related APIs that allows the end user to perform actions as create an account (/auth/register), save a data representation 
          (/user/save) and share a visualization with a friend (/user/share).
        </li>
      </ul>
      <div style="display: flex; justify-content:center; align-items: center; flex-direction: column; ">
        <img style="max-width: 100%" src="./diagrams/frontend_architecture.png" />
        <figcaption style="font-style: italic; margin-top: 12px;">Fig.2 - ODa Frontend architecture</figcaption>
      </div>
      <p>For the frontend we've decided to use React as the frontend backbone because of the flexibility this library offers. With the help of React we can create SPA's that 
        can easily act both as an application and a browser extension. Diving deeper into the React app, we can see the following modules
      </p>
      <ul>
        <li>
          <b>Client state management - Zustand</b> : Zustand is a state management library that is built on top of React.
           It is very lightweight and easy to use. It is also very flexible and allows us to create our own state management system.
        </li>
        <li>
          <b> d3-sparql </b> is a JavaScript library that allows you to visualize SPARQL query results with D3.js, a popular data visualization library. The library provides an interface for fetching query results from a SPARQL endpoint and transforming them into the format required by D3, making it easy to create interactive, dynamic visualizations based on linked data.
        </li>
        <li>
          <b>Routing - react-router</b> : react-router is a routing library for React. It allows us to create routes and navigate between them.
        </li>
        <li>
          <b>Charts - Recharts</b> : Recharts is a charting library for React. It is very flexible and allows us to create different types of charts.
        </li>
      </ul>
    </section>

    <section id="software-design">
      <h2><span>4. </span>Software Design</h2>
      <p>
        We've designed a set of diagrams that will explain all the flow that the users can have within the application as well as how the modules of our application interact 
        with each other and what's the sequence of the actions that the user can perform. 
      </p>
      <section id="software-design-uml-activity">
        <h3><span>4.1 </span>UML Activity Diagram</h3>
        <div style="display: flex; justify-content:center; align-items: center; flex-direction: column; ">
          <img style="max-width: 90%" src="./diagrams/uml_activity_diagram.png" />
          <figcaption style="font-style: italic; margin-top: 12px;">Fig.3 - ODa UML Activity Diagram</figcaption>
        </div>
        <p>
          The activity diagram describes the flow of the user actions within the application in order of their execution. When the user will first enter the application he 
          can directly input the SPARQL query in the query editor and execute it. After the query has been executed and the user received the data he can choose which columns he wants to
          visualize and what type of visualization he wants to use. After the user has chosen the columns and the type of visualization he will see the visualization.
          The user then can save the visualization if he wants to for later use, but in order to do that he will have to create an account. If the user already has an account he can login.
          After the user has logged in he can save the visualization and use it later. The user can also share the visualization with other users. The user can use other users's visualisations 
          if they shared their visualisations with the respective user. 
        </p>
      </section>
      <section id="software-design-use-case">
        <h3><span>4.2 </span>UML Use Case Diagram</h3>
        <div style="display: flex; justify-content:center; align-items: center; flex-direction: column;">
          <img style="max-width: 90%" src="./diagrams/uml_use_case_diagram.png" />
          <figcaption style="font-style: italic;margin-top: 12px;">Fig.4 - ODa UML Use Case Diagram</figcaption>
        </div>
        <p>
          The use case diagram describes the users we will have in our application and the actions that they can perform. 
          We will have 2 types of users: the users that are not logged in and the users that are logged in which are called unauthorised and authorised user.
          Unauthorised users can perform the following actions
          <ul>
            <li>
              Execute SPARQL queries
            </li>
            <li>
              Visualize the data with the desired visualization and with the desired columns
            </li>
            <li>
              Create an account
            </li>
            <li>
              Login
            </li>
            <li>
              View other user's visualizations if those are publicly available
            </li>
          </ul>
          Authorised users can perform all the actions unauthorised can and also the following actions
          <ul>
            <li>
              Save the visualizations
            </li>
            <li>
              View saved visualizations
            </li>
            <li>
              Share the visualizations with other users
            </li>
            <li>
              View other user's visualizations if the user has the permission to view them
            </li>
        </p>
      </section>
      <section id="software-design-use-case">
        <h3><span>4.3 </span>UML Sequence Diagram</h3>
        <div style="display: flex; justify-content:center; align-items: center; flex-direction: column;">
          <img style="max-width: 90%" src="./diagrams/uml_sequence_diagram.png" />
          <figcaption style="font-style: italic; margin-top: 12px;">Fig.5 - ODa UML Sequence Diagram</figcaption>
        </div>
        <p>
          The sequence diagram describes how modules interact with each other based on the user actions. ODa module represents the front-end application and is the only thing that the user interacts with.
          The ODa module will send the SPARQL query to the SPARQL Query Route. The SPARQL Query Route will send the query to the SPARQL endpoint and will receive the data.
          The SPARQL Query Route will send the data to the ODa module and the ODa module will display the data to the user. The user can then choose which columns he wants to visualize and what type of visualization he wants to use.
          The ODa module within it will create the visualization and will show it to the user.
          If the user wants to save the visualization he will have to create an account or login if he already has an account.
          The ODa module will send the request to the Auth Route with the credentials the user entered.
          The Auth Route will check if the user credentials are valid and will send back the response if the user is allowed to save the visualization.
          If the user is allowed to save the visualization the ODa module will send the request to the User Route with the data of the visualization.
          The User Route will save the visualization in the Database and will send back the response to the ODa module.
          If the user wants to share the visualization with other users he will select which visualization he wants to share.
          The ODa module will send the request to the User Route with the data of the visualization.
          The User Route will change the permissions to the visualization and will send back the response to the ODa module.
          If the user wants to view other user's visualizations he will enter the link of the visualization.
          The ODa module will send the request to the User Route with the link of the visualization.
          The User Route will check if the user has the permission to view the visualization and will send back the response to the ODa module.
        </p>
      </section>
    </section>

    <section id="front-end">
      <h2><span>5. </span>Front-End</h2>
      <section id="front-end-vite">
        <h3><span>5.1 </span>Vite</h3>
        <p>
          Vite is a build tool that aims to provide a faster and leaner development experience for modern web projects. It consists of two major parts:
          <ul>
            <li>
              A dev server that provides rich feature enhancements over native ES modules, for example extremely fast Hot Module Replacement (HMR).
            </li>
            <li>
              A build command that bundles your code with Rollup, pre-configured to output highly optimized static assets for production.
            </li>
          </ul>
          Vite is opinionated and comes with a number of built-in features out of the box, such as:
          <ul>
            <li>
              ES module based dev server that supports native ESM imports during development.
            </li>
            <li>
              Rich feature enhancements over native ES modules, for example extremely fast Hot Module Replacement (HMR).
            </li>
            <li>
              Rollup based build command that bundles your code with Rollup, pre-configured to output highly optimized static assets for production.
            </li>
            <li>
              TypeScript support.
            </li>
            <li>
              JSX/TSX support.
            </li>
        </p>
      </section>
      <section id="front-end-react">
        <h3><span>5.2 </span>React with TypeScript</h3>
        <p>
          React is a JavaScript library for building user interfaces. It is maintained by Facebook and a community of individual developers and companies.
          React can be used as a base in the development of single-page or mobile applications. However, React is only concerned with rendering data to the DOM, and so creating React applications usually requires the use of additional libraries for state management and routing.
          TypeScript is an open-source language which builds on JavaScript, one of the world’s most used tools, by adding static type definitions.
          TypeScript saves you time catching errors and providing fixes before you run code.
          TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.
          Any browser. Any host. Any OS. Open source.
        </p>
      </section>
      <section id="front-end-mantine">
        <h3><span>5.3</span> Mantine UI</h3>
        <p>
          Mantine is a React UI library that provides a set of components and hooks to build your own design system or design a new website.
          It has multiple utilities that we've used across the app
          <ul>
            <li>
              <code>@mantine/core</code> - Mantine core components, such as buttons, inputs, selects, etc.
              <div style="display:flex;flex-direction:column; align-items:center;">
              <img style="max-width: 100%; margin-top: 12px;" src="./screenshots/ui_core_components.png" />
                <figcaption style="font-style: italic; margin-top: 12px; margin-bottom:12px">Fig.6 - UI Built with Mantine</figcaption>
              </div>


            </li>
            <li>
              <code>@mantine/form</code> - Mantine form components, such as form, form control, form error, etc.
              <div style="display:flex;flex-direction:column; align-items:center;">
                <img style="max-width: 100%; margin-top: 12px;" src="./screenshots/form_example.png" />
                  <figcaption style="font-style: italic; margin-top: 12px; margin-bottom:12px">Fig.7 - Form Built with Mantine</figcaption>
                </div>
            </li>
            <li>
              <code>@mantine/hooks</code> - Mantine hooks, such as use-id, use-merge-refs, use-previous-value, etc.
            </li>
            <li>
              <code>@mantine/styles</code> - Mantine styles, such as create-mantine-theme, create-use-styles, etc.
            </li>
            <li>
              <code>@mantine/theme</code> - Mantine theme, such as MantineProvider, use-mantine-theme, etc.
            </li>
            <li><code>@mantine/notifications</code> - Mantine notifications, mainly the showNotification function.</li>
          </ul>
        </p>
      </section>

      <section id="front-end-zustand">
        <h3><span>5.4</span> Zustand</h3>
        <p>
          We have two stores across the app, one for the user and one for the visualizations.
          <ul>
            <li>
              <code>userStore</code> - The user store is used to store the user's data, such as the username, the email, the avatar, bearer token etc.
              Also, this store persists, so the user's data is stored in the local storage.
              <div style="display:flex;flex-direction:column; align-items:center;">
                <img style="max-width: 100%; margin-top: 12px;" src="./screenshots/userStore.png" />
                  <figcaption style="font-style: italic; margin-top: 12px; margin-bottom:12px">Fig.8 - User Store</figcaption>
                </div>
            </li>
            <li>
              <code>applicationStore</code> - The application store is used to store the visualizations data, such as the title, the description, the data, the type of chart, as well as the steps of the visualization creation process.
              <div style="display:flex;flex-direction:column; align-items:center;">
                <img style="max-width: 100%; margin-top: 12px;" src="./screenshots/applicationStore.png" />
                  <figcaption style="font-style: italic; margin-top: 12px; margin-bottom:12px">Fig.9 - Application store</figcaption>
                </div>
            </li>
          </ul>
          
        </p>
      </section>
      <section id="front-end-codeMirror">
        <h3><span>5.5</span> CodeMirror</h3>
        <p>
          CodeMirror is a versatile text editor implemented in JavaScript for the browser. It is specialized for editing code, and comes with a number of language modes and addons that implement more advanced editing functionality.
          We have used CodeMirror to implement the SPQRQL editor.
         </p>
         <p>
          <code>@uiw/react-codemirror</code> is a React library that provides a React component for integrating CodeMirror.
          The library wraps the CodeMirror editor in a React component, making it easier to use and integrate into React projects, like ours.
          </p>
          <div style="display:flex;flex-direction:column; align-items:center;">
            <img style="max-width: 100%; margin-top: 12px;" src="./screenshots/codemirror.png" />
              <figcaption style="font-style: italic; margin-top: 12px; margin-bottom:12px">Fig.10 - CodeMirror in Theia</figcaption>
            </div>
      </section>

      <section id="front-end-recharts">
        <h3><span>5.6</span> Recharts</h3>
        <p>
          Recharts is a Redefined chart library built with React and D3.
          We have used Recharts to implement the charts.
          </p>
          <p>Example of implemented charts</p>
          <ul>
            <li>
              <code>BarChart</code> - Bar chart
              <div style="display:flex;flex-direction:column; align-items:center;">
                <img style="max-width: 100%; margin-top: 12px;" src="./screenshots/bar_chart.png" />
                  <figcaption style="font-style: italic; margin-top: 12px; margin-bottom:12px">Fig.11 - Bar Chart</figcaption>
                </div>
            </li>
            <li>
              <code>LineChart</code> - Line chart
              <div style="display:flex;flex-direction:column; align-items:center;">
                <img style="max-width: 100%; margin-top: 12px;" src="./screenshots/line_chart.png" />
                  <figcaption style="font-style: italic; margin-top: 12px; margin-bottom:12px">Fig.12 - Line Chart</figcaption>
                </div>
            </li>
            <li>
              <code>PieChart</code> - Pie chart
              <div style="display:flex;flex-direction:column; align-items:center;">
                <img style="max-width: 100%; margin-top: 12px;" src="./screenshots/pie_chart.png" />
                  <figcaption style="font-style: italic; margin-top: 12px; margin-bottom:12px">Fig.13 - Pie Chart</figcaption>
                </div>
            </li>
            <li>
              <code>ScatterChart</code> - Scatter chart
              <div style="display:flex;flex-direction:column; align-items:center;">
                <img style="max-width: 100%; margin-top: 12px;" src="./screenshots/scatter_chart.png" />
                  <figcaption style="font-style: italic; margin-top: 12px; margin-bottom:12px">Fig.14 - Scatter Chart</figcaption>
                </div>
            </li>
            <li>
              <code>RadarChart</code> - Radar Chart
              <div style="display:flex;flex-direction:column; align-items:center;">
                <img style="max-width: 100%; margin-top: 12px;" src="./screenshots/radar_chart.png" />
                  <figcaption style="font-style: italic; margin-top: 12px; margin-bottom:12px">Fig.15 - Radar Chart</figcaption>
                </div>
            </li>
            <li>
              <code>Radial Chart</code> - Radial Chart
              <div style="display:flex;flex-direction:column; align-items:center;">
                <img style="max-width: 100%; margin-top: 12px;" src="./screenshots/radial_chart.png" />
                  <figcaption style="font-style: italic; margin-top: 12px; margin-bottom:12px">Fig.16 - Radial Chart</figcaption>
                </div>
            </li>

          </ul>
      </section>

      <section id="front-end-jsonld">
        <h3><span>5.7</span>JSON-LD Detection</h3>

        <p>
          JSON-LD is a JSON-based format to serialize <a href="https://www.w3.org/TR/json-ld/">Linked Data</a>. 
          It is designed to be easy to read for humans and to be easy to generate and parse by machines. 
          JSON-LD is primarily intended to be a way to use Linked Data in Web-based programming environments, 
          to build interoperable Web services, and to store Linked Data in JSON-based storage engines.
        </p>
        <p>
          We have used <code>schema-dts</code> and <code>react-schemaorg</code> to place JSON-LD on our pages so that search engines can understand the content of our pages.
        </p>
        <p>
          The types of JSON-LD we have used are:
          <ul>
        <li>
          <code>WebApplication</code>
        </li>
        <li>
          <code>WebPage</code>
        </li>
        <li>
          <code>Dataset</code>
        </li>
        <li>
          <code>Collection</code>
        </li>
        <li>
          <code>CollectionPage</code>
        </li>
        <li>
          <code>CreativeWork</code>
        </li>
        <li>
          <code>Table</code>
        </li>
        <li>
          <code>Recommendation</code>
        </li>
          </ul>
        <div style="display:flex;flex-direction:column; align-items:center;">
          <img style="max-width: 100%; margin-top: 12px;" src="./screenshots/json_ld.png" />
          <figcaption style="font-style: italic; margin-top: 12px; margin-bottom:12px">Fig.17 - OpenLink Structured Data Sniffer Page Analysis</figcaption>
        </div>
        </p>
      </section>


    </section>

    <section id="spqrql">
      <h2><span>6. </span>SPQRQL and Datasets</h2>
      <p>
        The application will be used by users to represent different kind of data in several types of charts. 
        The information is retireved via a SPARQL endpoint implemented in <a href="https://nodejs.org/en/">Node.js</a> from different open datasets.
      </p>
      <section id="sparql-subsection">
        <h3><span>6.1 </span>SPAQRL</h3>
        <p>
          SPARQL is a <a href="https://www.w3.org/TR/sparql11-query/">query language</a> and a 
          <a href="https://www.w3.org/TR/rdf-sparql-protocol/">protocol</a> 
          for accessing RDF designed by <a href="https://www.w3.org/2009/sparql/wiki/Main_Page">W3C</a>. 
        </p>
        <p>
          As a query language, SPARQL is “data-oriented” in that it only queries the information held in the models; 
          there is no inference in the query language itself.  Of course, the Jena model may be ‘smart’ in that it 
          provides the impression that certain triples exist by creating them on-demand, including OWL reasoning. 
          SPARQL does not do anything other than take the description of what the application wants, in the form of a query, 
          and returns that information, in the form of a set of bindings or an RDF graph. (Apache Jena)
        </p>
      </section>
      <section id="datasets">
        <h3><span>6.2 </span>Datasets</h3>
        <p>
          In ODA, when an user wants to retireve data by writing an SPARQL query in the page query editor, they will be able 
          to specify which open dataset they target. Being a flexible application, user has the posibility to insert the link of
          the most used open datasets:
          <ul>
            <li>
              <a href="https://www.dbpedia.org/">Dbpedia</a>
            </li>
            <li>
              <a href="https://www.wikidata.org/wiki/Wikidata:Main_Page">Wikidata</a>
            </li>
          </ul>
        </p>
      </section>
      <section id="sparql-endpoint">
        <h3><span>6.3 </span>SPARQL endpoint</h3>
        <p>
          In order to retireve data from chosen open dataset, the user has to write a SPQRQL query in the 
          query editor. When submitting the written query, an API call will be made by the front-end application.
          That API will execute the query on the specified open dataset and return the results in order to be 
          represented in different ways in the page application.
        </p>
        <p>
          The SPARQL endpoint is implemented in <a href="https://nodejs.org/en/">Node.js</a>, an open source server environment 
          which uses JavaScript in the server. The endpoint will use <a href="https://expressjs.com/">ExpressJS</a>, a minimal 
          and flexible <a href="https://nodejs.org/en/">Node.js</a> web application framework.
        </p>
        <p>
          We've decided to use the d3-sparql library in order to execute the SPARQL queries. The d3-sparql library is a
          <a href="https://www.npmjs.com/package/d3-sparql">Node.js</a> library that allows to execute SPARQL queries and
          to retrieve the results in JSON format. The library is based on the <a href="https://www.npmjs.com/package/sparql-client">sparql-client</a> library.
        </p>
        <p>
          We will have the following endpoints:
          <ul>
            <li>
              <code>POST /sparql/</code> - It takes JSON payload in the request body that contains two properties: endpoint and query.
              It uses the d3.sparql function to make a SPARQL query to the specified endpoint with the given query.
               The results are then processed using OpenAI's Generative Pre-trained Transformer 3 (GPT-3) <code>openai.createCompletion</code> function,
                to suggest a graph type and generate natural language descriptions of the data. Finally, the results and the graph suggestion are sent back as a JSON response.
            </li>
            <li>
              <code>POST /sparql/simple</code> - It is similar / route, but it does not make use of the OpenAI function.
               It only retrieves the results of the SPARQL query and returns them as a JSON response.
            </li>
        </p>
        <p>
          <span style="font-weight: 700;">Example Query</span>
          <pre><code>
            const bindingsStream = await queryEngine.queryBindings(
              `PREFIX dbo: <http://dbpedia.org/ontology/>
              PREFIX foaf: <http://xmlns.com/foaf/0.1/>
              PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> 
              SELECT ?country ?city ?city_name ?country_name
              WHERE {
                  ?city rdf:type dbo:City ;
                        foaf:name ?city_name ;
                        dbo:country ?country ;
                        dbo:populationTotal ?population ;
                        ?country rdf:type dbo:Country ;
                            foaf:name ?country_name .
              
                  ?country foaf:name \"Romania\"@en .
              
                  FILTER(langMatches(lang(?city_name), \"en\"))
              }
              ORDER BY ?city_name
              LIMIT 100`,
              {
                sources: ['https://dbpedia.org/sparql'],
              },
            );
          </code></pre>
        </p>
      </section>
      <section id="chartgpt">
        <h3><span>6.4 </span>ChatGPT (Generative Pre-trained Transformer)</h3>
        <p>
          As we mentioned before, we integrated the OpenAI tool ChatGPT in ODa application in order to obtain from this source 
          the best graph representation for the data retrieved from the open source dataset. The application has associated an 
          private OpenAI key thru which we query the ChatGPT to get the response. The query is executed via openai object's function 
          named "createCompletion", inserting as an argument "prompt" the question.

          <div style="display:flex;flex-direction:column; align-items:center;">
            <img style="max-width: 100%; margin-top: 12px;" src="./screenshots/createCompletion.png" />
            <figcaption style="font-style: italic; margin-top: 12px; margin-bottom:12px">Fig.18 - ChatGPT invocation</figcaption>
          </div>
        </p>
      </section>
    </section>
    <section id="user">
      <h2><span>7. </span>User management and Authentication modules</h2>
      <p>
        ODA application allows users to query an open dataset via a SPARQL endpoint implemented in Node.js as described above. ODa application allows 
        unauthenticated users to execute any SPARQL query having as source an open dataset, choose which chart to represent returned data and which fields to
        be included in the visualisation. In order to perform user related actions such as save, view saved representations and share they have to register 
        with an username and a password. Based on their credentials, 
        the users will be allowed to save and share an chart representation with another application user.
        As it can be seen in the project architecture presented above, there will be implementend two modules: open datasets queries and user management in 
        order to perform different actions to an executed query.
      </p>
      <section id="user-authentication">
        <h3><span>7.1 </span>Authentication module</h3>
          In order to save, share and view all its visualisations the users should have an account.
          For authentication there will be the following endpoints:
          <ul>
            <li>
              POST: <b>/auth/register</b> - create an user account
              <br/>
              Payload example: 
              <pre><code>
                {
                  "email": "joe.doe@example.com",
                  "name": "Joe Doe",
                  "password": "000000"
                }
              </code></pre>
            </li>
            <li>
              POST: <b>/auth/login</b> - get user account by id
              <br/>
              Payload example: 
              <pre><code>
                {
                  "email": "joe.doe@example.com",
                  "password": "000000"
                }
              </code></pre>
            </li>
          </ul>
      </section>
      <section id="user-management">
        <h3><span>7.2 </span>User module</h3>
        <p>
        Having an account, users are allowed to perform different actions related to executed queries across the application. 
        As mentioned before, a SPARQL query can be executed by an unauthorized user, but to save, share, view saved visualizations 
        there is a need of an account. An authorised user is able to save a certain visualization and add it in its 
        visualisation "library" which can be accesed in the left side menu of the application. After selecting a certain chart 
        to represent returned data by SPARQL endpoint, an authorized user can choose to share the respective chart visualisation 
        with a friend across the application by specifying its email.
        For this part of the application we implemented the following endpoints:
        </p>
        <ul>
          <li>
            POST: <b>/user/save</b> - save a SPARQL data chart representation
            <br/>
              Payload example:
              <pre><code>
                {
                  "email": "stefandr@gmail.com",
                  "query": "Select from queries where",
                  "type": "Bar chart",
                  "outValues": [
                    "genes"
                  ],
                  "entryValues": [
                    "name",
                    "level"
                  ],
                  "title": "My special representation",
                  "description": "a very nice representation made by me",
                  "source": ""
              }
              </code></pre>
          </li>
          <li>
            GET: <b>/user/</b> - get all user's saved queries (included those shared by its friends)
          </li>
          <li>
            GET: <b>/user/:id</b> - get by id a user SPARQL data chart representation
          </li>
          <li>
            POST: <b>/user/share</b> - share a SPARQL data chart representation with another user
            <br/>
            Payload example: 
              <br/>
              <pre><code>
                {
                  "userEmail": "joe.doe@example.com",
                  "queryId": "123-abx-xyz-987",
                  "friendEmail": "joe.doe.friend@example.com"
                }
              </code></pre>
          </li>
        </ul>
      </section>
    <section id="deployment">
      <h3><span>8. </span>Application Deploy</h3>
      <p>
        The React app will be hosted on Netlify, the Express app will be hosted on Fly.io.
      </p>
      <ul>
        <li>
          The React app is available at <a href="https://theia-oda.netlify.app/">https://theia-oda.netlify.app/</a>
        </li>
        <li>
          The API endpoints are available at <a href="https://theia-oda.fly.dev">https://theia-oda.fly.dev</a>
        </li>
      </ul>
      <p>
        Netlify is a cloud-based platform that provides hosting, continuous deployment, and management services for modern web applications. It is designed to simplify the development and deployment of web applications, allowing developers to focus on writing code while the platform takes care of the underlying infrastructure. Netlify supports a wide range of web technologies and provides a variety of tools and features for managing and optimizing web applications, such as automatic optimization for faster loading times, automatic SSL certificates, and custom domains.
      </p>
      <p>
        Fly.io is a cloud platform that provides hosting and management services for server-side applications, including those built with Express.js. It offers automatic scaling, global content delivery, and custom domains, as well as other features for managing and optimizing server-side applications. Fly.io provides a secure and reliable platform for deploying and running server-side applications, freeing developers from the complexities of managing infrastructure and allowing them to focus on writing code. The platform provides a simple and intuitive interface for managing server-side applications, making it an attractive option for us.
      </p>

    </section>
  </body>
</html>