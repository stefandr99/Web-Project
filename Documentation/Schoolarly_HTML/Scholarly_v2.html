<!DOCTYPE html>
<html>
  <head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Scholarly HTML</title>
    <link rel="stylesheet" href="./scholarly.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <script src="./Scholarly HTML_files/scholarly.min.js.download"></script>
  </head>
  <body prefix="schema: http://schema.org" cz-shortcut-listen="true">
    <div class="banner">
      <img src="./diagrams/scholarly-html.svg" width="227" height="50" alt="Scholarly HTML logo">
      <div class="status">Open Dataset Visualizer</div>
    </div>
    <header>
      <h1>ODA Scholarly HTML</h1>
    </header>
    <div role="contentinfo">
      <ol role="directory">
        <li><a href="#abstract"><span>1. </span>Abstract</a></li>
        <li><a href="#introduction"><span>2. </span>Introduction</a></li>
        <li><a href="#architecture"><span>3. </span>Arhitecture</a></li>
        <li><a href="#software-design"><span>4. </span>Software Design</a>
          <ol>
            <li><a href="#software-design-uml-activity"><span>4.1. </span>UML Activity Diagram</a></li>
            <li><a href="#software-design-use-case"><span>4.2. </span>UML Use Case Diagram</a></li>
            <li><a href="#software-design-use-case"><span>4.3. </span>UML Sequence Diagram</a></li>
          </ol>
        </li>
        <li><a href="#spqrql"><span>5. </span>SPARQL and Datasets</a>
          <ol>
            <li><a href="#sparql-subsection"><span>5.1. </span>SPARQL</a></li>
            <li><a href="#sparql-query-subsection"><span>5.2. </span>Comunica query-sparql library</a></li>
            <li><a href="#datasets"><span>5.2. </span>Datasets</a></li>
            <li><a href="#sparql-endpoint"><span>5.2. </span>SPARLQ endpoint</a></li>
          </ol>
        </li>
        <li><a href="#user"><span>6. </span>Authentication and authorization</a>
          <ol>
            <li><a href="#user-authentication"><span>6.1. </span>Authentication endpoints</a></li>
            <li><a href="#user-management"><span>6.2. </span>User endpoints</a></li>
          </ol>  
        </li>
      <dl>
        <dt>Authors</dt>
        <dd>
          Nazar Fatichov,
          Serghei Cunev 
          &amp;
          Ștefan Drăgoi
        </dd>
      </dl>
    </div>
    <section typeof="sa:Abstract" id="abstract" role="doc-abstract">
      <h2><span>1. </span>Abstract</h2>
      <p>
        ODA (Open Dataset Visualizer) is a semantic web applicaton which has the purpose to represent data 
        from open datasets in different forms. The main target of the application is to provide userful visualizations 
        to end users in order to understand better data / information / knowledge. The system is designed to allow users 
        to write a raw SPARQL queries specifying the dataset URL or to choose one of the application query from the top 
        right of the page. The users are able to select the type of chart to represent data, which fields to be included in 
        representation, to save a visualization and to share it with a friend.
      </p>
    </section>
    <section id="introduction" role="doc-introduction">
      <h2><span>2. </span>Introduction</h2>
      <p>
        Open Dataset Visualizer is a web application which will provide useful visualizations for better understanding of 
        data retrieved via a SPARQL endpoint. In order to use ODA, users should create an account (full name, email and password) 
        and based on the authorization JWT received once the login is successful, the user
        will be allowed to perform different actions:
        <ul>
          <li>
            write raw SPARQL queries in the application's query editor specifying the dataset URL where the data will be retrieved from
            or choose one "built-in" queries from the top-right select in the page;
          </li>
          <li>
            run the query and choose the chart type that will represent the retrieved data;
          </li>
          <li>
            choose a the fields that the user want to be included in the selected representation;
          </li>
          <li>
            save a representation;
          </li>
          <li>
            share a data visualization with another user by writing its email; 
          </li>
          <li>
            see all its saved visualizations;
          </li>
        </ul>
      </p>
      <p>
        The application is built in 2 modules (which will be described in the following document sections):
        <ul>
          <li>
            Backend module managing user data and executing the written SPARQL queries. It is an Web API 
            application with two types of endpoints: SPARQL endpoints (one with ChatGPT integration and one without) 
            and user endpoints (create account, login, save visualization, share and see saved data representations) 
          </li>
          <li>
            User interface and user experience: register, login, logout, write queries, visualize charts (represented data), 
            save and share charts
          </li>
        </ul>
      </p>
    </section>

    <section id="architecture">
      <h2><span>3. </span>Arhitecture</h2>
      <p>
        Our application architecture will be described via the following diagrams:
      </p>
      <div style="display: flex; justify-content:center; align-items: center; flex-direction: column; ">
        <img style="max-width: 100%" src="./diagrams/v2/backend_architecture.png" />
        <figcaption style="font-style: italic; margin-top: 12px;">Fig.1 - ODa Backend architecture</figcaption>
      </div>
      <p>For the backend we've decided to take a monolith approach, but dividing the routes in two categories: SPARQL endpoints 
        which retrieve data from open datasources based on a query plus asking ChatGPT related to the most suitable chart for the 
        given data and user endpoints which manage user management logic such as create an account, log in the application, save 
        a grapghic representation and share it with friends. Diving deeper into each of this two modules:</p>
      <ul>
        <li>
          <b>SPARQL module</b> - this controller will make use of openAI API which will allows us to interact with ChatGPT in order to
          receive the most suitable representation for that kind of data (obtained by executing SPARQL query). This one will generate also 
          a natural language description of the data which will be exposed to the end user in the interface.
        </li>
        <li>
          <b>User management module</b> - this module is responsible with user data management across the application. This controller has 
          several user related APIs that allows the end user to perform actions as create an account (/auth/register), save a data representation 
          (/user/save) and share a visualization with a friend (/user/share).
        </li>
      </ul>
      <div style="display: flex; justify-content:center; align-items: center; flex-direction: column; ">
        <img style="max-width: 100%" src="./diagrams/frontend_architecture.png" />
        <figcaption style="font-style: italic; margin-top: 12px;">Fig.2 - ODa Frontend architecture</figcaption>
      </div>
      <p>For the frontend we've decided to use React as the frontend backbone because of the flexibility this library offers. With the help of React we can create SPA's that 
        can easily act both as an application and a browser extension. Diving deeper into the React app, we can see the following modules
      </p>
      <ul>
        <li>
          <b>Client state management - Zustand</b> : Zustand is a state management library that is built on top of React.
           It is very lightweight and easy to use. It is also very flexible and allows us to create our own state management system.
        </li>
        <li>
          <b>Routing - react-router</b> : react-router is a routing library for React. It allows us to create routes and navigate between them.
        </li>
        <li>
          <b>SparQL Queries - Comunica</b> : Comunica is a SPARQL query engine that can be used to query SPARQL endpoints.
           It is very flexible and can be used in different environments.
        </li>
        <li>
          <b>Charts - Recharts</b> : Recharts is a charting library for React. It is very flexible and allows us to create different types of charts.
        </li>
        <li>
          <b>Visualizations: Recharts, React Chart js 2, Victory, Visx, Nivo</b> : We will use different charting libraries to create different types of charts or any other types of visualizations. 
        </li>
      </ul>
    </section>

    <section id="software-design">
      <h2><span>4. </span>Software Design</h2>
      <p>
        We've designed a set of diagrams that will explain all the flow that the users can have within the application as well as how the modules of our application interact 
        with each other and what's the sequence of the actions that the user can perform. 
      </p>
      <section id="software-design-uml-activity">
        <h3><span>4.1 </span>UML Activity Diagram</h3>
        <div style="display: flex; justify-content:center; align-items: center; flex-direction: column; ">
          <img style="max-width: 90%" src="./diagrams/uml_activity_diagram.png" />
          <figcaption style="font-style: italic; margin-top: 12px;">Fig.3 - ODa UML Activity Diagram</figcaption>
        </div>
        <p>
          The activity diagram describes the flow of the user actions within the application in order of their execution. When the user will first enter the application he 
          can directly input the SPARQL query in the query editor and execute it. After the query has been executed and the user received the data he can choose which columns he wants to
          visualize and what type of visualization he wants to use. After the user has chosen the columns and the type of visualization he will see the visualization.
          The user then can save the visualization if he wants to for later use, but in order to do that he will have to create an account. If the user already has an account he can login.
          After the user has logged in he can save the visualization and use it later. The user can also share the visualization with other users. The user can use other users's visualisations 
          if they shared their visualisations with the respective user. 
        </p>
      </section>
      <section id="software-design-use-case">
        <h3><span>4.2 </span>UML Use Case Diagram</h3>
        <div style="display: flex; justify-content:center; align-items: center; flex-direction: column;">
          <img style="max-width: 90%" src="./diagrams/uml_use_case_diagram.png" />
          <figcaption style="font-style: italic;margin-top: 12px;">Fig.4 - ODa UML Use Case Diagram</figcaption>
        </div>
        <p>
          The use case diagram describes the users we will have in our application and the actions that they can perform. 
          We will have 2 types of users: the users that are not logged in and the users that are logged in which are called unauthorised and authorised user.
          Unauthorised users can perform the following actions
          <ul>
            <li>
              Execute SPARQL queries
            </li>
            <li>
              Visualize the data with the desired visualization and with the desired columns
            </li>
            <li>
              Create an account
            </li>
            <li>
              Login
            </li>
            <li>
              View other user's visualizations if those are publicly available
            </li>
          </ul>
          Authorised users can perform all the actions unauthorised can and also the following actions
          <ul>
            <li>
              Save the visualizations
            </li>
            <li>
              View saved visualizations
            </li>
            <li>
              Share the visualizations with other users
            </li>
            <li>
              View other user's visualizations if the user has the permission to view them
            </li>
        </p>
      </section>
      <section id="software-design-use-case">
        <h3><span>4.3 </span>UML Sequence Diagram</h3>
        <div style="display: flex; justify-content:center; align-items: center; flex-direction: column;">
          <img style="max-width: 90%" src="./diagrams/uml_sequence_diagram.png" />
          <figcaption style="font-style: italic; margin-top: 12px;">Fig.5 - ODa UML Sequence Diagram</figcaption>
        </div>
        <p>
          The sequence diagram describes how modules interact with each other based on the user actions. ODa module represents the front-end application and is the only thing that the user interacts with.
          The ODa module will send the SPARQL query to the SPARQL Query Route. The SPARQL Query Route will send the query to the SPARQL endpoint and will receive the data.
          The SPARQL Query Route will send the data to the ODa module and the ODa module will display the data to the user. The user can then choose which columns he wants to visualize and what type of visualization he wants to use.
          The ODa module within it will create the visualization and will show it to the user.
          If the user wants to save the visualization he will have to create an account or login if he already has an account.
          The ODa module will send the request to the Auth Route with the credentials the user entered.
          The Auth Route will check if the user credentials are valid and will send back the response if the user is allowed to save the visualization.
          If the user is allowed to save the visualization the ODa module will send the request to the User Route with the data of the visualization.
          The User Route will save the visualization in the Database and will send back the response to the ODa module.
          If the user wants to share the visualization with other users he will select which visualization he wants to share.
          The ODa module will send the request to the User Route with the data of the visualization.
          The User Route will change the permissions to the visualization and will send back the response to the ODa module.
          If the user wants to view other user's visualizations he will enter the link of the visualization.
          The ODa module will send the request to the User Route with the link of the visualization.
          The User Route will check if the user has the permission to view the visualization and will send back the response to the ODa module.

        </p>
      </section>
    </section>

    <section id="spqrql">
      <h2><span>5. </span>SPQRQL and Datasets</h2>
      <p>
        The application will be used by users to represent different kind of data in several types of charts. 
        The information is retireved via a SPARQL endpoint implemented in <a href="https://nodejs.org/en/">Node.js</a> from different open datasets.
      </p>
      <section id="sparql-subsection">
        <h3><span>5.1 </span>SPAQRL</h3>
        <p>
          SPARQL is a <a href="https://www.w3.org/TR/sparql11-query/">query language</a> and a 
          <a href="https://www.w3.org/TR/rdf-sparql-protocol/">protocol</a> 
          for accessing RDF designed by <a href="https://www.w3.org/2009/sparql/wiki/Main_Page">W3C</a>. 
        </p>
        <p>
          As a query language, SPARQL is “data-oriented” in that it only queries the information held in the models; 
          there is no inference in the query language itself.  Of course, the Jena model may be ‘smart’ in that it 
          provides the impression that certain triples exist by creating them on-demand, including OWL reasoning. 
          SPARQL does not do anything other than take the description of what the application wants, in the form of a query, 
          and returns that information, in the form of a set of bindings or an RDF graph. (Apache Jena)
        </p>
      </section>
      <section id="sparql-query-subsection">
        <h3><span>5.2 </span>Comunica query-sparql library</h3>
        <p>
          <a href="https://www.npmjs.com/package/@comunica/query-sparql">Comunica SPARQL</a> is a SPARQL query engine for 
          JavaScript for querying over decentralized RDF knowledge graphs on the Web.
          It's main distinguishing features are the following:
          <ul>
            <li>
              Execute SPARQL 1.1 or GraphQL-LD queries;
            </li>
            <li>
              Federated querying over heterogeneous interfaces, such as RDF files, SPARQL endpoints, Triple Pattern Fragments, or Solid data pods;
            </li>
            <li>
              High modularity enabling easy extensions and customization.
            </li>
          </ul>
        </p>
      </section>
      <section id="datasets">
        <h3><span>5.3 </span>Datasets</h3>
        <p>
          In ODA, when an user wants to retireve data by writing an SPARQL query in the page query editor, they will be able 
          to specify which open dataset they target. Being a flexible application, user has the posibility to insert the link of
          the most used open datasets:
          <ul>
            <li>
              <a href="https://www.dbpedia.org/">Dbpedia</a>
            </li>
            <li>
              <a href="https://www.wikidata.org/wiki/Wikidata:Main_Page">Wikidata</a>
            </li>
          </ul>
        </p>
      </section>
      <section id="sparql-endpoint">
        <h3><span>5.4 </span>SPARLQ endpoint</h3>
        <p>
          In order to retireve data from chosen open dataset, the user has to write a SPQRQL query in the 
          query editor. When submitting the written query, an API call will be made by the front-end application.
          That API will execute the query on the specified open dataset and return the results in order to be 
          represented in different ways in the page application.
        </p>
        <p>
          The SPARQL endpoint is implemented in <a href="https://nodejs.org/en/">Node.js</a>, an open source server environment 
          which uses JavaScript in the server. The endpoint will use <a href="https://expressjs.com/">ExpressJS</a>, a minimal 
          and flexible <a href="https://nodejs.org/en/">Node.js</a> web application framework.
        </p>
        <p>
          We've decided to use the d3-sparql library in order to execute the SPARQL queries. The d3-sparql library is a
          <a href="https://www.npmjs.com/package/d3-sparql">Node.js</a> library that allows to execute SPARQL queries and
          to retrieve the results in JSON format. The library is based on the <a href="https://www.npmjs.com/package/sparql-client">sparql-client</a> library.
        </p>
        <p>
          We will have the following endpoints:
          <ul>
            <li>
              <code>POST /sparql/</code> - It takes JSON payload in the request body that contains two properties: endpoint and query.
              It uses the d3.sparql function to make a SPARQL query to the specified endpoint with the given query.
               The results are then processed using OpenAI's Generative Pre-trained Transformer 3 (GPT-3) <code>openai.createCompletion</code> function,
                to suggest a graph type and generate natural language descriptions of the data. Finally, the results and the graph suggestion are sent back as a JSON response.
            </li>
            <li>
              <code>POST /sparql/simple</code> - It is similar / route, but it does not make use of the OpenAI function.
               It only retrieves the results of the SPARQL query and returns them as a JSON response.
            </li>
        </p>
        <p>
          <span style="font-weight: 700;">Example Query</span>
          <pre><code>
            const bindingsStream = await queryEngine.queryBindings(
              `PREFIX dbo: <http://dbpedia.org/ontology/>
              PREFIX foaf: <http://xmlns.com/foaf/0.1/>
              PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> 
              SELECT ?country ?city ?city_name ?country_name
              WHERE {
                  ?city rdf:type dbo:City ;
                        foaf:name ?city_name ;
                        dbo:country ?country ;
                        dbo:populationTotal ?population ;
                        ?country rdf:type dbo:Country ;
                            foaf:name ?country_name .
              
                  ?country foaf:name \"Romania\"@en .
              
                  FILTER(langMatches(lang(?city_name), \"en\"))
              }
              ORDER BY ?city_name
              LIMIT 100`,
              {
                sources: ['https://dbpedia.org/sparql'],
              },
            );
          </code></pre>
        </p>
      </section>
    </section>
    <section id="user">
      <h2><span>6. </span>User management module</h2>
      <p>
        ODA application allows users to query an open dataset via a SPARQL endpoint implemented in Node.js as described above. ODa application allows 
        unauthenticated users to execute any SPARQL query having as source an open dataset, choose which chart to represent returned data and which fields to
        be included in the visualisation. In order to perform user related actions such as save, view saved representations and share they have to register 
        with an username and a password. Based on their credentials, 
        the users will be allowed to save and share an chart representation with another application user.
        As it can be seen in the project architecture presented above, there will be implementend two modules: open datasets queries and user management in 
        order to perform different actions to an executed query.
      </p>
      <section id="user-authentication">
        <h3><span>6.1 </span>Authentication endpoints</h3>
          In order to save, share and view all its visualisations the users should have an account.
          For authentication there will be the following endpoints:
          <ul>
            <li>
              POST: <b>/auth/register</b> - create an user account
              <br/>
              Payload example: 
              <br/>
              <code>
                {
                  <br/>
                  &emsp;"email": "joe.doe@example.com",
                  <br/>
                  &emsp;"name": "Joe Doe",
                  <br/>
                  &emsp;"password": "000000"
                  <br/>
                }
              </code>
            </li>
            <li>
              POST: <b>/auth/login</b> - get user account by id
              <br/>
              Payload example: 
              <br/>
              <code>
                {
                  <br/>
                  &emsp;"email": "joe.doe@example.com",
                  <br/>
                  &emsp;"password": "000000"
                  <br/>
                }
              </code>
            </li>
          </ul>
      </section>
      <section id="user-management">
        <h3><span>6.2 </span>User endpoints</h3>
        Having an account, users are allowed to perform different actions related to executed queries across the application. 
        As mentioned before, a SPARQL query can be executed by an unauthorized user, but to save, share, view saved visualizations 
        there is a need of an account. An authorised user is able to save a certain visualization and add it in its 
        visualisation "library" which can be accesed in the left side menu of the application. After selecting a certain chart 
        to represent returned data by SPARQL endpoint, an authorized user can choose to share the respective chart visualisation 
        with a friend across the application by specifying its email.
        For this part of the application we implemented the following endpoints:
        <ul>
          <li>
            POST: <b>/user/save</b> - save a SPARQL data chart representation
            <br/>
              Payload example: 
              <br/>
              <code>
                {
                  <br/>
                  &emsp;"email": "stefandr@gmail.com",
                  <br/>
                  &emsp;"query": "Select from queries where",
                  <br/>
                  &emsp;"type": "Bar chart",
                  <br/>
                  &emsp;"outValues": [
                  <br/>
                    &emsp;&emsp;&emsp;"genes"
                    <br/>
                    &emsp;],
                  <br/>
                  &emsp;"entryValues": [
                  <br/>
                    &emsp;&emsp;&emsp;"name",
                    <br/>
                    &emsp;&emsp;&emsp;"level"
                    <br/>
                    &emsp;],
                  <br/>
                    &emsp;"title": "My special representation",
                  <br/>
                  &emsp;"description": "a very nice representation made by me",
                  <br/>
                  &emsp;"source": ""
                  <br/>
              }
              </code>
          </li>
          <li>
            GET: <b>/user/</b> - get all user's saved queries (included those shared by its friends)
          </li>
          <li>
            GET: <b>/user/:id</b> - get by id a user SPARQL data chart representation
          </li>
          <li>
            POST: <b>/user/share</b> - share a SPARQL data chart representation with another user
            <br/>
            Payload example: 
              <br/>
              <code>
                {
                  <br/>
                  &emsp;"userEmail": "joe.doe@example.com",
                  <br/>
                  &emsp;"queryId": "123-abx-xyz-987",
                  <br/>
                  &emsp;"friendEmail": "joe.doe.friend@example.com"
                  <br/>
                }
          </li>
        </ul>
      </section>
    </section>